!>-------------------------------------------------------------------------------
!!
{
NAME: "rfoMM.bas",
AUTHOR: "REBELS130",
LICENSE: "GPLv3",
CLASS: "rfoMM",
VER: "0.20",
USER FUNCTIONS: 
[
"MM_CREATE(TYPE$)",
"MM_CREATE$(TYPE$)",
"MM_KEYS(MM_ADDRESS$)",
"MM_KEYS$(MM_ADDRESS$)",
"MM_TYPE$(MM_ADDRESS$)",
"MM_DELETE(MM_ADDRESS$)",
"MM_EXISTS(MM_ADDRESS$)",
"MM_EXISTS$(MM_ADDRESS$)",
"MM_POINTER(MM_ADDRESS$)",
"MM_VALIDATE$(MM_ADDRESS$)",
"MM_LOAD$(STRUCT_ID, MM_TYPE$)",
"MM_ADDRESS$(STRUCT_ID, MM_TYPE$)"
],
INTERNAL FUNCTIONS: 
[
"MM_INIT()",
"MM_OPEN(TYPE$)",
"MM_RECYCLE(TYPE$)",
],
HELPER FUNCTIONS:
[
MM_LOAD_TYPE$(STRUCT_ID, TYPE$)
],
WISH LIST:
[
],
DESCRIPTION:
"
THE MAIN INCLUDE FILE FOR THE MEMORY
MANAGMENT CLASS IN THE rfOOP LIBRARY
"
}
!!


!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_INIT()",
DESCRIPTION:
" 
THIS FUNCTION WILL INITIALIZE THE rfOOP
MEMORY MANAGEMENT CLASS AND ENVIRONMENT
"
}
!!


FN.DEF MM_INIT()

   ! CREATE THE RFO DATA STRUCTURES NEEDED FOR VALID OBJECT AND ADDITIONAL PROPERTIES

   LIST.CREATE       N,       IN_USE_BUNDLES
   LIST.CREATE       N,       IN_USE_STRING_LISTS
   LIST.CREATE       N,       IN_USE_NUMERIC_LISTS  
   LIST.CREATE       N,       OPEN_BUNDLES
   LIST.CREATE       N,       OPEN_STRING_LISTS
   LIST.CREATE       N,       OPEN_NUMERIC_LISTS
   LIST.CREATE       N,       CLASSES
   LIST.CREATE       N,       OBJECTS
   
   BUNDLE.CREATE     MEMORY_ADDRESSES
   BUNDLE.CREATE     MEMORY_TYPES
   BUNDLE.CREATE     CLASS_VARIABLES
   BUNDLE.CREATE     OBJECT_VARIABLES
   BUNDLE.CREATE     TYPINGS
   BUNDLE.CREATE     rfoMM

   STACK.CREATE      N,       THIS


   ! INITIALIZE THE VALUES FOR THE PROPERTIES

   BUNDLE.PUT    rfoMM,    "INDEX",                   rfoMM
   BUNDLE.PUT    rfoMM,    "NAME",                    "rfoMM"
   BUNDLE.PUT    rfoMM,    "TYPE",                    "rfOOP OBJECT"
   BUNDLE.PUT    rfoMM,    "SUB TYPE",                "rfOOP OBJECT"
   BUNDLE.PUT    rfoMM,    "TYPINGS",                 TYPINGS
   BUNDLE.PUT    rfoMM,    "CLASS VARIABLES",         CLASS_VARIABLES
   BUNDLE.PUT    rfoMM,    "OBJECT VARIABLES",        OBJECT_VARIABLES
   BUNDLE.PUT    rfoMM,    "IN-USE BUNDLES",          IN_USE_BUNDLES
   BUNDLE.PUT    rfoMM,    "IN-USE STRING LISTS",     IN_USE_STRING_LISTS
   BUNDLE.PUT    rfoMM,    "IN-USE NUMERIC LISTS",    IN_USE_NUMERIC_LISTS 
   BUNDLE.PUT    rfoMM,    "OPEN BUNDLES",            OPEN_BUNDLES
   BUNDLE.PUT    rfoMM,    "OPEN STRING LISTS",       OPEN_STRING_LISTS
   BUNDLE.PUT    rfoMM,    "OPEN NUMERIC LISTS",      OPEN_NUMERIC_LISTS                          
   BUNDLE.PUT    rfoMM,    "rfOOP MEMORY STACK",      THIS
   BUNDLE.PUT    rfoMM,    "CLASSES",                 CLASSES
   BUNDLE.PUT    rfoMM,    "OBJECTS",                 OBJECTS
   BUNDLE.PUT    rfoMM,    "MEMORY ADDRESSES",        MEMORY_ADDRESSES
   BUNDLE.PUT    rfoMM,    "MEMORY TYPES",            MEMORY_TYPES
   BUNDLE.PUT    rfoMM,    "TOTAL MEMORY",            TOTAL_MEMORY


   MM_INIT_TYPINGS(TYPINGS)


   ! PLACE THE MEMORY MANAGEMENT CLASS IN BUNDLE 1 AND ADD THE CLASS TO THE CLASS LIST 

   BUNDLE.PUT    1,          "rfoMM",    rfoMM
   LIST.ADD      CLASSES,    rfoMM

FN.END


!>-------------------------------------------------------------------------------
!!
{
HELPER FUNCTION: "MM_INIT_TYPINGS(TYPINGS)",
ARGS: [TYPINGS: "B"]
DESCRIPTION:
"
THIS IS A HELPER FUNCTION THAT INITIALIZES THE TYPINGS FOR 
CREATED RFO DATA STRUCTURES IN THE MEMORY MANAGEMENT CLASS
"
}
!!


FN.DEF MM_INIT_TYPINGS(TYPINGS)

   BUNDLE.PUT    TYPINGS,    "INDEX",                "P"
   BUNDLE.PUT    TYPINGS,    "NAME",                 "S"
   BUNDLE.PUT    TYPINGS,    "TYPE",                 "S"
   BUNDLE.PUT    TYPINGS,    "SUB TYPE",             "S"
   BUNDLE.PUT    TYPINGS,    "TYPINGS",              "B"
   BUNDLE.PUT    TYPINGS,    "CLASS VARIABLES",      "B"
   BUNDLE.PUT    TYPINGS,    "OBJECT VARIABLES",     "B"
   BUNDLE.PUT    TYPINGS,    "IN-USE BUNDLES",       "NL"
   BUNDLE.PUT    TYPINGS,    "IN-USE STRING LISTS",  "NL"
   BUNDLE.PUT    TYPINGS,    "IN-USE NUMERIC LISTS", "NL"
   BUNDLE.PUT    TYPINGS,    "OPEN BUNDLES",         "NL"
   BUNDLE.PUT    TYPINGS,    "OPEN STRING LISTS",    "NL"
   BUNDLE.PUT    TYPINGS,    "OPEN NUMERIC LISTS",   "NL"
   BUNDLE.PUT    TYPINGS,    "rfOOP MEMORY STACK",   "P"
   BUNDLE.PUT    TYPINGS,    "CLASSES",              "NL"
   BUNDLE.PUT    TYPINGS,    "OBJECTS",              "NL"
   BUNDLE.PUT    TYPINGS,    "MEMORY ADDRESSES",     "B"
   BUNDLE.PUT    TYPINGS,    "MEMORY TYPES",         "B"
   BUNDLE.PUT    TYPINGS,    "AVAILABLE MEMORY",     "SL"
   BUNDLE.PUT    TYPINGS,    "TOTAL MEMORY",         "N"

FN.END


!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_CREATE(TYPE$)",
ARGS: [TYPE$: ["B", "SL", "NL", "C", "O"]],
RETURNS: "STRUCT ID",
DESCRIPTION:
"
CREATE A NEW DATA STRUCT OR USES AN AVAILABLE RESOURCE 
AND STORES IT IN THE RFO MEMORY MANAGEMENT ENVIRONMENT
"
}
!!


FN.DEF MM_CREATE(TYPE$)
   
   ADDRESS$ = MM_CREATE$(TYPE$)
   
   ADDRESS = MM_POINTER(ADDRESS$)
   
   FN.RTN ADDRESS

FN.END


!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_CREATE$(TYPE$)",
ARGS: [TYPE$: ["B", "SL", "NL", "C", "O"]],
RETURNS: "MEMORY_ADDRESS$",
DESCRIPTION:
"
CREATE A NEW DATA STRUCT OR USES AN AVAILABLE RESOURCE 
AND STORES IT IN THE RFO MEMORY MANAGEMENT ENVIRONMENT
"
}
!!


FN.DEF MM_CREATE$(TYPE$)

   BUNDLE.GET     1,     "rfoMM",          rfoMM_OBJECT

   IF TYPE$ = "C"
      IF !MM_OPEN("B")
         BUNDLE.CREATE   MM_STRUCT
         BUNDLE.GET      rfoMM_OBJECT,     "IN-USE BUNDLES",   IN_USE_BUNDLES
         BUNDLE.GET      rfoMM_OBJECT,     "CLASSES",          CLASSES
         LIST.ADD        IN_USE_BUNDLES,   MM_STRUCT
         LIST.ADD        CLASSES,          MM_STRUCT
      ELSE
         MM_STRUCT      =  MM_RECYCLE("B")
         BUNDLE.GET     rfoMM_OBJECT,      "IN-USE BUNDLES",   IN_USE_BUNDLES
         BUNDLE.GET     rfoMM_OBJECT,      "CLASSES",          CLASSES
         LIST.ADD       IN_USE_BUNDLES,    MM_STRUCT
         LIST.ADD       CLASSES,           MM_STRUCT
      END IF
   ELSEIF TYPE$ = "O"
      IF !MM_OPEN("B")
         BUNDLE.CREATE  MM_STRUCT
         BUNDLE.GET     rfoMM_OBJECT,      "IN-USE BUNDLES",   IN_USE_BUNDLES
         BUNDLE.GET     rfoMM_OBJECT,      "OBJECTS",          OBJECTS
         LIST.ADD       IN_USE_BUNDLES,    MM_STRUCT
         LIST.ADD       OBJECTS,           MM_STRUCT
      ELSE
         MM_STRUCT      = MM_RECYCLE("B")
         BUNDLE.GET     rfoMM_OBJECT,      "IN-USE BUNDLES",   IN_USE_BUNDLES
         BUNDLE.GET     rfoMM_OBJECT,      "OBJECTS",          OBJECTS
         LIST.ADD       IN_USE_BUNDLES,    MM_STRUCT
         LIST.ADD       OBJECTS,           MM_STRUCT
      END IF 
   ELSEIF TYPE$ = "B"
      IF !MM_OPEN("B") 
         BUNDLE.CREATE  MM_STRUCT
         BUNDLE.GET     rfoMM_OBJECT,     "IN-USE BUNDLES",    IN_USE_BUNDLES
         LIST.ADD       IN_USE_BUNDLES,   MM_STRUCT
      ELSE
         MM_STRUCT      = MM_RECYCLE("B")
         BUNDLE.GET     rfoMM_OBJECT,     "IN-USE BUNDLES",    IN_USE_BUNDLES
         LIST.ADD       IN_USE_BUNDLES,   MM_STRUCT
      END IF            
   ELSEIF TYPE$ = "SL"   
      IF !MM_OPEN("SL")  
         LIST.CREATE  S,                   MM_STRUCT
         BUNDLE.GET   rfoMM_OBJECT,        "IN-USE STRING LISTS", IN_USE_STRING_LISTS
         LIST.ADD     IN_USE_STRING_LISTS, MM_STRUCT
      ELSE
         MM_STRUCT    = MM_RECYCLE("SL")
         BUNDLE.GET   rfoMM_OBJECT,        "IN-USE STRING LISTS", IN_USE_STRING_LISTS
         LIST.ADD     IN_USE_STRING_LISTS, MM_STRUCT
      END IF
   ELSEIF TYPE$ = "NL"
      IF !MM_OPEN("NL")
         LIST.CREATE  N, MM_STRUCT
         BUNDLE.GET   rfoMM_OBJECT,       "IN-USE NUMERIC LISTS", IN_USE_NUMERIC_LISTS
         LIST.ADD                         IN_USE_NUMERIC_LISTS,   MM_STRUCT
      ELSE
         MM_STRUCT   = MM_RECYCLE("NL")
         BUNDLE.GET  rfoMM_OBJECT,        "IN-USE NUMERIC LISTS", IN_USE_NUMERIC_LISTS
         LIST.ADD                         IN_USE_NUMERIC_LISTS,   MM_STRUCT
      END IF
   ELSE
      PRINT "MEMORY MANAGMENT ERROR: '" + TYPE$ + "' IS NOT A SUPPORTED TYPE"
      END
   END IF
   
   ADDRESS$ = MM_LOAD$(MM_STRUCT, TYPE$)
   
   FN.RTN ADDRESS$

FN.END


!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_OPEN(TYPE$)",
ARGS: [TYPE$: ["B", "SL", "NL"]],
RETURNS: "STRUCT ID",
DESCRIPTION:
"
CHECK A DATA STRUCTURE TYPE FOR THE NEXT OPEN REFERENCE 
(TYPE$) 'B' BUNDLE, 'SL' STRING LIST, 'NL' NUMERIC LIST
"
}
!!


FN.DEF MM_OPEN(TYPE$)

   BUNDLE.GET 1, "rfoMM", rfoMM_OBJECT

   IF TYPE$ = "B"
      BUNDLE.GET rfoMM_OBJECT, "OPEN BUNDLES", OPEN_BUNDLES
      LIST.SIZE OPEN_BUNDLES, TOTAL_OPEN
      IF TOTAL_OPEN
         LIST.GET OPEN_BUNDLES, 1, MM_STRUCT
      ELSE
         MM_STRUCT = 0
      END IF
   ELSEIF TYPE$ = "SL"
      BUNDLE.GET rfoMM_OBJECT, "OPEN STRING LISTS", OPEN_STRING_LISTS
      LIST.SIZE OPEN_STRING_LISTS, TOTAL_OPEN
      IF TOTAL_OPEN
         LIST.GET OPEN_STRING_LISTS, 1, MM_STRUCT
      ELSE
         MM_STRUCT = 0
      END IF 
   ELSEIF TYPE$ = "NL"
      BUNDLE.GET rfoMM_OBJECT, "OPEN NUMERIC LISTS", OPEN_NUMERIC_LISTS
      LIST.SIZE OPEN_NUMERIC_LISTS, TOTAL_OPEN
      IF TOTAL_OPEN
         LIST.GET OPEN_NUMERIC_LISTS, 1, MM_STRUCT
      ELSE
         MM_STRUCT = 0
      END IF
   ELSE
      PRINT "MEMORY MANAGMENT ERROR: '" + TYPE$ + "' IS NOT A SUPPORTED TYPE"
      END
   END IF

   FN.RTN MM_STRUCT

FN.END

!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_RECYCLE(TYPE$)",
ARGS: [TYPE$: ["B", "SL", "NL"]],
RETURNS: "STRUCT ID",
DESCRIPTION:
"
RECYCLE DATA STRUCTURE TYPE FOR THE NEXT OPEN REFERENCE 
(TYPE$) "B" BUNDLE, "SL" STRING LIST, "NL" NUMERIC LIST
"
}
!!


FN.DEF MM_RECYCLE(TYPE$)

   BUNDLE.GET 1, "rfoMM", rfoMM_OBJECT
   
   IF TYPE$ = "B"
      BUNDLE.GET rfoMM_OBJECT, "OPEN BUNDLES", OPEN_BUNDLES
      LIST.SIZE OPEN_BUNDLES, AVAILABLE_BUNDLES
      IF AVAILABLE_BUNDLES > 0
         LIST.GET OPEN_BUNDLES, 1, MM_STRUCT
         LIST.REMOVE OPEN_BUNDLES, 1
      ELSE
         MM_STRUCT = MM_CREATE("B")
      END IF
   ELSEIF TYPE$ = "SL"
      BUNDLE.GET rfoMM_OBJECT, "OPEN STRING LISTS", OPEN_STRING_LISTS
      LIST.SIZE OPEN_STRING_LISTS, AVAILABLE_STRING_LISTS
      IF AVAILABLE_STRING_LISTS > 0
         LIST.GET OPEN_STRING_LISTS, 1, MM_STRUCT
         LIST.REMOVE OPEN_STRING_LISTS, 1
      ELSE
         MM_STRUCT = MM_CREATE("SL")
      END IF      
   ELSEIF TYPE$ = "NL"
      BUNDLE.GET rfoMM_OBJECT, "OPEN NUMERIC LISTS", OPEN_NUMERIC_LISTS
      LIST.SIZE OPEN_NUMERIC_LISTS, AVAILABLE_NUMERIC_LISTS
      IF AVAILABLE_NUMERIC_LISTS > 0
         LIST.GET OPEN_NUMERIC_LISTS, 1, MM_STRUCT
         LIST.REMOVE OPEN_NUMERIC_LISTS, 1
      ELSE
         MM_STRUCT = MM_CREATE("NL")
      END IF 
   ELSE
      PRINT "MEMORY MANAGMENT ERROR: '" + TYPE$ + "' IS NOT A SUPPORTED TYPE"
   END IF 
   
   FN.RTN MM_STRUCT
   
FN.END


!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_ADDRESS$(STRUCT_ID, TYPE$)",
ARGS: [STRUCT_ID: "x>0", TYPE$ ['B','SL','NL']],
RETURNS: "MEMORY ADDRESS"
DESCRIPTION:
"
FETCHES THE MEMORY ADDRESS ASSOCIATED 
WITH THE RFO POINTER ID AND DATA TYPE
"
}
!!


FN.DEF MM_ADDRESS$(STRUCT_ID, TYPE$)

   BUNDLE.GET 1,                "rfoMM",              rfoMM_OBJECT
   BUNDLE.GET rfoMM_OBJECT,     "TOTAL MEMORY",   TOTAL_MEMORY
   BUNDLE.GET rfoMM_OBJECT,     "MEMORY ADDRESSES",   MEMORY_ADDRESSES
   BUNDLE.GET rfoMM_OBJECT,     "MEMORY TYPES",       MEMORY_TYPES
   
   IF STRUCT_ID < 1 | TOTAL_MEMORY < 1
      FN.RTN ""
   END IF 

   FOR MEMORY = 1 TO TOTAL_MEMORY
      LOOK_UP$ = "rfoMM(" + INT$(MEMORY) + ")" 
      BUNDLE.CONTAIN MEMORY_ADDRESSES, LOOK_UP$, ADDRESS_EXISTS
      IF ADDRESS_EXISTS
         BUNDLE.GET MEMORY_ADDRESSES, LOOK_UP$, ADDRESS
      
         IF ADDRESS = STRUCT_ID
            BUNDLE.GET MEMORY_TYPES, LOOK_UP$, MEMORY_TYPE$
            IF MEMORY_TYPE$ = TYPE$
               ADDRESS$ = LOOK_UP$
               F_N.BREAK
            ENDIF
         ENDIF
      ENDIF 
   NEXT MEMORY

   FN.RTN ADDRESS$

FN.END

!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_DELETE(MM_ADDRESS$)",
ARGS: [MM_ADDRESS$: ["rfoMM(x)"]],
DESCRIPTION:
"
DELETES MM_ADDRESS$ FROM
MEMORY MANAGEMENT SYSTEM
"
}
!!


FN.DEF MM_DELETE(MM_ADDRESS$)

   BUNDLE.GET      1,               "rfoMM",            rfoMM_OBJECT
   BUNDLE.GET      rfoMM_OBJECT,    "MEMORY ADDRESSES", MEMORY_ADDRESSES
   BUNDLE.GET      rfoMM_OBJECT,    "MEMORY TYPES",     MEMORY_TYPES
   BUNDLE.CONTAIN  MEMORY_ADDRESSES, MM_ADDRESS$,       ADDRESS_EXISTS
   
   IF ADDRESS_EXISTS
      BUNDLE.GET     MEMORY_ADDRESSES,  MM_ADDRESS$,    MM_POINTER
      BUNDLE.GET     MEMORY_TYPES,      MM_ADDRESS$,    MM_TYPE$
      BUNDLE.REMOVE  MEMORY_ADDRESSES,  MM_ADDRESS$
      BUNDLE.REMOVE  MEMORY_TYPES,      MM_ADDRESS$
   ELSE
      MM_TYPE$ = "UNDEFINED"
   ENDIF
   
   SW.BEGIN MM_TYPE$
   
      SW.CASE "C"
         BUNDLE.GET   rfoMM_OBJECT,  "CLASSES",       CLASSES
         BUNDLE.GET   rfoMM_OBJECT,  "OPEN BUNDLES",  OPEN_BUNDLES
         LIST.SEARCH  CLASSES,       MM_POINTER,      CLASS_EXISTS
         BUNDLE.CLEAR MM_POINTER                  
         LIST.REMOVE  CLASSES,       CLASS_EXISTS
         LIST.ADD     OPEN_BUNDLES,  MM_POINTER
         SW.BREAK
      SW.CASE "O"
         BUNDLE.GET   rfoMM_OBJECT,  "OBJECTS", OBJECTS
         BUNDLE.GET   rfoMM_OBJECT,  "OPEN BUNDLES",  OPEN_BUNDLES
         LIST.SEARCH  OBJECTS,       MM_POINTER, OBJECT_EXISTS
         BUNDLE.CLEAR MM_POINTER            
         LIST.REMOVE  OBJECTS,       OBJECT_EXISTS
         LIST.ADD     OPEN_BUNDLES,  MM_POINTER
         SW.BREAK
      SW.CASE "B"
         BUNDLE.GET   rfoMM_OBJECT,   "IN-USE BUNDLES", IN_USE_BUNDLES
         BUNDLE.GET   rfoMM_OBJECT,   "OPEN BUNDLES",   OPEN_BUNDLES
         LIST.SEARCH  IN_USE_BUNDLES, MM_POINTER,       BUNDLE_EXISTS
         BUNDLE.CLEAR MM_POINTER
         LIST.REMOVE  IN_USE_BUNDLES, BUNDLE_EXISTS     
         LIST.ADD     OPEN_BUNDLES,   MM_POINTER
         SW.BREAK
      SW.CASE "SL"
         BUNDLE.GET   rfoMM_OBJECT,        "IN-USE STRING LISTS", IN_USE_STRING_LISTS
         BUNDLE.GET   rfoMM_OBJECT,        "OPEN STRING LISTS",   OPEN_STRING_LISTS
         LIST.SEARCH  IN_USE_STRING_LISTS, MM_POINTER,            STRING_LIST_EXISTS
         LIST.CLEAR   MM_POINTER      
         LIST.REMOVE  IN_USE_STRING_LISTS, STRING_LIST_EXISTS
         LIST.ADD     OPEN_STRING_LISTS,   MM_POINTER
         SW.BREAK
      SW.CASE "NL"
         BUNDLE.GET   rfoMM_OBJECT,         "IN-USE NUMERIC LISTS", IN_USE_NUMERIC_LISTS
         BUNDLE.GET   rfoMM_OBJECT,         "OPEN NUMERIC LISTS", OPEN_NUMERIC_LISTS
         LIST.SEARCH  IN_USE_NUMERIC_LISTS, MM_POINTER, NUMERIC_LISTS_EXISTS
         LIST.CLEAR   MM_POINTER  
         LIST.REMOVE  IN_USE_NUMERIC_LISTS, NUMERIC_LISTS_EXISTS    
         LIST.ADD     OPEN_NUMERIC_LISTS,   MM_POINTER
         SW.BREAK
      SW.CASE "UNDEFINED"
         PRINT "MEMORY MANAGEMENT ERROR: '" + MM_ADDRESS$ + "'DOES NOT EXIST IN MEMORY"
      SW.DEFAULT
         PRINT "MEMORY MANAGEMENT ERROR: '" + MM_TYPE$ + "' IS NOT A SUPPORTED TYPE"
   SW.END
   
FN.END

!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_POINTER(MM_ADDRESS$)",
ARGS: [MM_ADDRESS$: "rfoMM(x)"]
RETURNS: "STRUCT ID"
DESCRIPTION:
"
RETRIEVES THE RFO BASIC STRUCT ID ASSOCIATED 
TO A REGISTERED MEMORY ADDRESS (MM_ADDRESS$)
"
}
!!


FN.DEF MM_POINTER(MM_ADDRESS$)

   BUNDLE.GET 1,                 "rfoMM",              rfoMM_OBJECT
   BUNDLE.GET rfoMM_OBJECT,      "MEMORY ADDRESSES",   MEMORY_ADDRESSES   
   BUNDLE.CONTAIN MEMORY_ADDRESSES, MM_ADDRESS$, ADDRESS_EXISTS
   
   IF ADDRESS_EXISTS
      BUNDLE.GET MEMORY_ADDRESSES,  MM_ADDRESS$,          MM_POINTER
   ELSE
      MM_POINTER = 0
   END IF 
   
   FN.RTN MM_POINTER

FN.END

!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_TYPE$(MM_ADDRESS$)",
ARGS: [MM_ADDRESS$: "rfoMM(X)"],
RETURNS: "ADDRESS_TYPE$",
DESCRIPTION:
"
CHECK TYPE OF MM_ADDRESS$ IF IS A rfoMM DATA STRUCTURE THIS RETURNS 'B' BUNDLE 'SL' 
STRING LIST, 'NL' NUMERIC LIST, 'CB' CLASS, OR 'OB' OBJECT ELSE RETURNS 'UNDEFINED'
"
}
!!


FN.DEF MM_TYPE$(MM_ADDRESS$)

   BUNDLE.GET 1, "rfoMM", rfoMM_OBJECT
   BUNDLE.GET rfoMM_OBJECT, "MEMORY ADDRESSES", MEMORY_ADDRESSES
   BUNDLE.GET rfoMM_OBJECT, "MEMORY TYPES", MEMORY_TYPES
   BUNDLE.CONTAIN MEMORY_TYPES, MM_ADDRESS$, ADDRESS_EXISTS
   
   IF ADDRESS_EXISTS
      BUNDLE.GET MEMORY_TYPES, MM_ADDRESS$, MM_TYPE$
   ELSE
      MM_TYPE$ = "UNDEFINED"
   END IF  

   FN.RTN MM_TYPE$

FN.END

!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_EXISTS$(MM_ADDRESS$)",
ARGS: [MM_ADDRESS$: "rfoMM(x)"]
RETURNS: "STRING BOOLEAN"
DESCRIPTION:
"
CHECK TO SEE IF MM_ADDRESS$ IS IN 
THE MEMORY MANAGEMENT ENVIRONMENT
"
}
!!


FN.DEF MM_EXISTS$(MM_ADDRESS$)

   BUNDLE.GET 1, "rfoMM", rfoMM_OBJECT
   BUNDLE.GET rfoMM_OBJECT, "MEMORY ADDRESSES", MEMORY_ADDRESSES
   
   BUNDLE.CONTAIN MEMORY_ADDRESSES, MM_ADDRESS$, ADDRESS_EXISTS

   IF ADDRESS_EXISTS
      FN.RTN "TRUE"
   ELSE
      FN.RTN "FALSE"
   ENDIF

FN.END


!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_EXISTS(MM_ADDRESS)",
ARGS: [MM_ADDRESS$: "rfoMM(x)"]
RETURNS: "NUMERIC BOOLEAN"
DESCRIPTION:
"
CHECK TO SEE IF MM_ADDRESS$ IS IN 
THE MEMORY MANAGEMENT ENVIRONMENT
"
}
!!


FN.DEF MM_EXISTS(MM_ADDRESS$)

   IF MM_EXISTS$(MM_ADDRESS$) = "TRUE"
      ADDRESS_EXISTS = 1
   ELSE
      ADDRESS_EXISTS = 0
   END IF 
   
   FN.RTN ADDRESS_EXISTS

FN.END


!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_VALIDATE$(MM_ADDRESS$)",
ARGS: [MM_ADDRESS$: "rfoMM(x)"],
RETURNS: "STRING BOOLEAN",
DESCRIPTION:
"
THIS FUNCTION VALIDATES THE BUNDLE PASSED AS AN 
rfOOP OBJECT OR CLASS AND RETURNS TRUE OR FALSE
"
}
!!


FN.DEF MM_VALIDATE$(MM_ADDRESS$)

   IF MM_EXISTS$(MM_ADDRESS$) = "TRUE"
      STATUS$ = "TRUE"
      MM_POINTER = MM_POINTER(MM_ADDRESS$)
   END IF 
   
   IF MM_POINTER > 0
      MM_TYPE$ = MM_TYPE$(MM_ADDRESS$)
 
      BUNDLE.CONTAIN MM_POINTER, "NAME", NAME_EXISTS
      BUNDLE.CONTAIN MM_POINTER, "INDEX", INDEX_EXISTS
      BUNDLE.CONTAIN MM_POINTER, "TYPE", TYPE_EXISTS
      BUNDLE.CONTAIN MM_POINTER, "SUB TYPE", SUBTYPE_EXISTS
      BUNDLE.CONTAIN MM_POINTER, "TYPINGS", TYPINGS_EXISTS
      BUNDLE.CONTAIN MM_POINTER, "CLASS VARIABLES", CLAVAR_EXISTS
      BUNDLE.CONTAIN MM_POINTER, "OBJECT VARIABLES", OBJVAR_EXISTS
   END IF 
      
   IF NAME_EXISTS & INDEX_EXISTS & TYPE_EXISTS & SUBTYPE_EXISTS & TYPINGS_EXISTS &   CLAVAR_EXISTS & OBJVAR_EXISTS
      STATUS$ = "TRUE"
   ELSE
      STATUS$ = "FALSE"
   END IF
   
   FN.RTN STATUS$

FN.END

!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_KEYS(MM_ADDRESS$)",
ARGS: [MM_ADDRESS$: "rfoMM(x)"],
RETURNS: "STRUCT ID",
DESCRIPTION:
"
RFO BASIC CREATES A NEW LIST EACH TIME BUNDLE.KEYS IS CALLED 
WITH THIS WE LOAD EACH LIST TO rfoMM FOR SAFE DELETION LATER
"
}
!!


FN.DEF MM_KEYS(MM_ADDRESS$)

   MM_KEYS = MM_KEYS$(MM_ADDRESS$)
   MM_ADDRESS = MM_POINTER(MM_KEYS)
   
   FN.RTN MM_ADDRESS

FN.END


!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_KEYS$(MM_ADDRESS$)",
ARGS: [MM_ADDRESS$: "rfoMM(x)"],
RETURNS: "MEMORY_ADDRESS$",
DESCRIPTION:
"
RFO BASIC CREATES A NEW LIST EACH TIME BUNDLE.KEYS IS CALLED 
WITH THIS WE LOAD EACH LIST TO rfoMM FOR SAFE DELETION LATER
"
}
!!


FN.DEF MM_KEYS$(MM_ADDRESS$)

   MM_POINTER  = MM_POINTER(MM_ADDRESS$)
   BUNDLE.KEYS   MM_POINTER, MM_KEYS
   MM_KEYS$    = MM_LOAD$(MM_KEYS, "SL")
   
   FN.RTN MM_KEYS$

FN.END

!>-------------------------------------------------------------------------------
!!
{
FUNCTION: "MM_LOAD$(STRUCT_ID, TYPE$)",
ARGS: [STRUCT_ID: "x>0", TYPE$: ['B','SL','NL']]
RETURNS: "MEMORY ADDRESS"
DESCRIPTION:
"
THIS FUNCTION CREATES A NEW MEMORY ADDRESS AND 
ADDS IT TO THE MEMORY MANAGEMENT MEMORY BUNDLE
"
}
!!


FN.DEF MM_LOAD$(STRUCT_ID, TYPE$)

   IF STRUCT_ID < 1
      FN.RTN ""
   END IF 

   BUNDLE.GET 1,                "rfoMM",              rfoMM_OBJECT

   BUNDLE.GET rfoMM_OBJECT,     "MEMORY ADDRESSES",   MEMORY_ADDRESSES
   BUNDLE.GET rfoMM_OBJECT,     "MEMORY TYPES",       MEMORY_TYPES
   BUNDLE.GET rfoMM_OBJECT,     "TOTAL MEMORY",       TOTAL_MEMORY

   TOTAL_MEMORY = ++TOTAL_MEMORY
   ADDRESS$ = "rfoMM(" + INT$(TOTAL_MEMORY) + ")"

   BUNDLE.PUT MEMORY_ADDRESSES,  ADDRESS$,             STRUCT_ID
   BUNDLE.PUT MEMORY_TYPES,      ADDRESS$,             TYPE$
   BUNDLE.PUT rfoMM_OBJECT,      "TOTAL MEMORY",       TOTAL_MEMORY
   
   MM_LOAD_TYPE$(STRUCT_ID, TYPE$)

   FN.RTN ADDRESS$

FN.END


!>-------------------------------------------------------------------------------
!!
{
HELPER FUNCTION: "MM_LOAD_TYPE$(STRUCT_ID, TYPE$)",
ARGS: [STRUCT_ID: "x>0", TYPE$: ['B','SL','NL']]
RETURNS: ""
DESCRIPTION:
"
THIS FUNCTION DOES THE ACTUAL LOADING OF THE 
NEW MEMORY ADDRESS USING THE STRUCT_ID GIVEN
"
}
!!


FN.DEF MM_LOAD_TYPE$(STRUCT_ID, TYPE$)

   BUNDLE.GET     1,     "rfoMM",          rfoMM_OBJECT

   IF TYPE$ = "C"
      BUNDLE.GET      rfoMM_OBJECT,     "IN-USE BUNDLES",   IN_USE_BUNDLES
      BUNDLE.GET      rfoMM_OBJECT,     "CLASSES",          CLASSES
      LIST.ADD        IN_USE_BUNDLES,   STRUCT_ID
      LIST.ADD        CLASSES,          STRUCT_ID
   ELSEIF TYPE$ = "O"
      BUNDLE.GET     rfoMM_OBJECT,      "IN-USE BUNDLES",   IN_USE_BUNDLES
      BUNDLE.GET     rfoMM_OBJECT,      "OBJECTS",          OBJECTS
      LIST.ADD       IN_USE_BUNDLES,    STRUCT_ID
      LIST.ADD       OBJECTS,           STRUCT_ID
   ELSEIF TYPE$ = "B"
      BUNDLE.GET     rfoMM_OBJECT,     "IN-USE BUNDLES",    IN_USE_BUNDLES
      LIST.ADD       IN_USE_BUNDLES,   STRUCT_ID          
   ELSEIF TYPE$ = "SL"   
      BUNDLE.GET   rfoMM_OBJECT,        "IN-USE STRING LISTS", IN_USE_STRING_LISTS
      LIST.ADD     IN_USE_STRING_LISTS, STRUCT_ID
   ELSEIF TYPE$ = "NL"
      BUNDLE.GET   rfoMM_OBJECT,       "IN-USE NUMERIC LISTS", IN_USE_NUMERIC_LISTS
      LIST.ADD                         IN_USE_NUMERIC_LISTS,   STRUCT_ID
   ELSE
      PRINT "MEMORY MANAGMENT ERROR: '" + TYPE$ + "' IS NOT A SUPPORTED TYPE"
      END
   END IF

FN.END





